package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"strconv"

	"github.com/Moral-Authority/backend/database"
	"github.com/Moral-Authority/backend/graph/model"
	"github.com/Moral-Authority/backend/handlers"
)

// AddCertification is the resolver for the addCertification field.
func (r *mutationResolver) AddCertification(ctx context.Context, input model.AddCertification) (*model.Certification, error) {
	dbService := &database.CertificationDbServiceImpl{}
	cert, err := handlers.CertificationService{}.AddNewCertification(input, dbService)
	if err != nil {
		return cert, err
	}

	return cert, nil
}

// UpdateCertification is the resolver for the updateCertification field.
func (r *mutationResolver) UpdateCertification(ctx context.Context, input model.UpdateCertification) (*model.Certification, error) {
	dbService := &database.CertificationDbServiceImpl{}
	certs, err := handlers.CertificationService{}.UpdateCertification(input, dbService)
	if err != nil {
		return certs, err
	}

	return nil, nil
}

// GetAllCertifications is the resolver for the getAllCertifications field.
func (r *queryResolver) GetAllCertifications(ctx context.Context) ([]*model.Certification, error) {
	dbService := &database.CertificationDbServiceImpl{}
	certs, err := handlers.CertificationService{}.GetAllCertifications(dbService)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve certifications in resolver: %w", err)
	}

	return certs, nil
}

// GetCertificationByID is the resolver for the getCertificationById field.
func (r *queryResolver) GetCertificationByID(ctx context.Context, id string) (*model.Certification, error) {
	panic(fmt.Errorf("not implemented: GetCertificationByID - getCertificationById"))
}

// GetCertificationsByFilter is the resolver for the getCertificationsByFilter field.
func (r *queryResolver) GetCertificationsByFilter(ctx context.Context, input model.FilterCertificationsInput) (*model.PaginatedCertifications, error) {
	dbService := &database.CertificationDbServiceImpl{}

	filters := map[string]interface{}{
		"name":                 input.CertificationFilters.Name,
		"industry":             input.CertificationFilters.Industry,
		"certifier":            input.CertificationFilters.Certifier,
		"certifies_company":    input.CertificationFilters.CertifiesCompany,
		"certifies_product":    input.CertificationFilters.CertifiesProduct,
		"certifies_process":    input.CertificationFilters.CertifiesProcess,
		"certifier_contact_id": input.CertificationFilters.CertifierContactID,
		"audited":              input.CertificationFilters.Audited,
		"auditor":              input.CertificationFilters.Auditor,
		"region":               input.CertificationFilters.Region,
		"qualifiers":           input.CertificationFilters.Qualifiers,
	}

	certifications, total, err := dbService.GetCertificationsByFilter(filters, input)
	if err != nil {
		return nil, err
	}

	var result []*model.Certification
	for _, cert := range certifications {
		result = append(result, &model.Certification{
			ID:                 *handlers.UintPtrToStringPtr(&cert.ID),
			Name:               cert.Name.String,
			Website:            &cert.Website.String,
			Logo:               &cert.Logo.String,
			Description:        &cert.Description.String,
			Industry:           &cert.Industry.String,
			Certifier:          &cert.Certifier.String,
			CertifiesCompany:   &cert.CertifiesCompany.Bool,
			CertifiesProduct:   &cert.CertifiesProduct.Bool,
			CertifiesProcess:   &cert.CertifiesProcess.Bool,
			CertifierContactID: &cert.CertifierContactID.String,
			Audited:            &cert.Audited.Bool,
			Auditor:            &cert.Auditor.String,
			Region:             &cert.Region.String,
			Qualifiers:         &cert.Qualifiers.String,
			Sources:            &cert.Sources.String,
		})
	}

	pagination := input.Pagination
	itemsPerPage := strconv.Itoa(*pagination.Items)
	currentPage := strconv.Itoa(int(*pagination.Page))

	return &model.PaginatedCertifications{
		Certifications: result,
		TotalItems:     strconv.Itoa(int(total)),
		ItemsPerPage:   &itemsPerPage,
		CurrentPage:    &currentPage,
		// TotalPages:     (total + int(pagination.Items) - 1) / int(pagination.Items), // Calculate total pages
	}, nil
}
